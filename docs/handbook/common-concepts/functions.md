### Функции (Functions) в Carbon

Функции — это основные строительные блоки программ на Carbon. Они позволяют структурировать код, повторно использовать логику и изолировать задачи. Вот ключевые аспекты работы с функциями:

---

#### 1. **Объявление функций**
Функции объявляются с использованием ключевого слова `fn`. Синтаксис:  
```carbon
fn имя_функции(параметры) -> возвращаемый_тип {
    // Тело функции
}
```

Пример:  
```carbon
fn add(a: i32, b: i32) -> i32 {
    return a + b;
}
```

---

#### 2. **Параметры и аргументы**
- Параметры указываются в формате `имя: тип`.  
- Передача по значению (по умолчанию) или по ссылке (с использованием `&`):  
  ```carbon
  fn increment(x: &i32) -> i32 {
      return *x + 1;
  }
  ```
- **Значения по умолчанию** (если поддерживаются):  
  ```carbon
  fn greet(name: String = "Гость") -> String {
      return "Привет, {name}!";
  }
  ```

---

#### 3. **Возвращаемые значения**
- Указывается после `->`. Если функция не возвращает значение, тип опускается:  
  ```carbon
  fn logMessage(text: String) {
      Print(text);
  }
  ```
- **Ключевое слово `return`**:  
  - Если `return` отсутствует, функция возвращает результат последнего выражения в блоке:  
    ```carbon
    fn square(x: i32) -> i32 {
        x * x // Неявный возврат
    }
    ```

---

#### 4. **Область видимости**
- Функции объявляются на уровне модуля или внутри структур/классов.  
- **Вложенные функции** (если поддерживаются):  
  ```carbon
  fn outer() {
      fn inner() { // Функция внутри outer
          Print("Вложенная");
      }
      inner();
  }
  ```

---

#### 5. **Перегрузка функций (Overloading)**
Carbon не поддерживает перегрузку функций на уровне имени. Для разных сигнатур используются уникальные имена:  
```carbon
fn multiplyInt(a: i32, b: i32) -> i32 { ... }
fn multiplyFloat(a: f64, b: f64) -> f64 { ... }
```

---

#### 6. **Методы (Функции структур и классов)**
Функции могут быть привязаны к типам данных (например, структурам):  
```carbon
struct Vector {
    x: f64,
    y: f64,
}

impl Vector {
    fn length(self) -> f64 {
        return Math.sqrt(self.x * self.x + self.y * self.y);
    }
}

// Использование:
let vec = Vector { x: 3.0, y: 4.0 };
Print(vec.length()); // 5.0
```

---

#### 7. **Обработка ошибок**
Вместо исключений часто используется тип `Result<T, E>` (как в разделе Data Types):  
```carbon
fn parseNumber(s: String) -> Result<i32, String> {
    // Попытка преобразования строки в число
    if (s.isNumeric()) {
        return Result.Ok(s.to_i32());
    } else {
        return Result.Err("Ошибка преобразования");
    }
}
```

---

#### 8. **Рекурсия**
Carbon поддерживает рекурсивные вызовы:  
```carbon
fn factorial(n: i32) -> i32 {
    if (n <= 1) {
        return 1;
    }
    return n * factorial(n - 1);
}
```

---

#### 9. **Анонимные функции (Лямбды)**
Если Carbon поддерживает лямбда-выражения, синтаксис может быть похож на:  
```carbon
let sum = fn (a: i32, b: i32) -> i32 { a + b };
Print(sum(2, 3)); // 5
```

---

#### 10. **Точка входа: функция `main`**
Программа начинается с выполнения `main`:  
```carbon
fn main() -> {
    Print("Запуск программы");
    let result = add(5, 3);
    Print(result); // 8
}
```

---

#### Особенности функций в Carbon:
- **Четкая типизация**: Все параметры и возвращаемые значения имеют явные типы.  
- **Иммутабельность по умолчанию**: Параметры передаются как константы, если не указано иное (например, через `&mut` для изменяемых ссылок).  
- **Нет неявных преобразований**: Типы аргументов должны точно совпадать с ожидаемыми.  

---

#### Пример комплексной функции:
```carbon
// Расчет среднего значения массива
fn average(values: [f64]) -> Option<f64> {
    if (values.isEmpty()) {
        return Option.none();
    }
    var sum: f64 = 0.0;
    for (var v in values) {
        sum += v;
    }
    return Option.some(sum / values.size());
}
```

---

Функции в Carbon сочетают гибкость с безопасностью, что делает их мощным инструментом для создания надежных приложений. 